<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Application - Three.js</title>
    <link rel="stylesheet" href="style.css">
   
</head>
<body>
    <div id="content">
        <!-- Side Navigation Menu -->
        <div id="mySidenav">
            <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
            <div class="menu-grid" id="thumbnail-container">
            </div>
        </div>

        <button class="open-menu" onclick="openNav()">â˜° Menu</button>

        <div id="loading" class="loading hidden">Loading...</div>

        <div id="container"></div>

        <!-- AR Place Button -->
        <button id="place-button" class="hidden">PLACE</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

        // Global variables
        let scene, camera, renderer, controls;
        let currentObject = null;
        let reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let objLoader, mtlLoader;
        let thumbnails = [];
        let selectedThumbnailIndex = 0;
        let thumbnailRenderer, thumbnailScene, thumbnailCamera;

        const mtlData = `
newmtl mat21
Ka 1.0 1.0 1.0
Kd 1.0 1.0 1.0
Ks 0.5 0.5 0.5
Ns 96.0

newmtl mat23
Ka 0.01 0.01 0.01
Kd 0.01 0.01 0.01
Ks 0.5 0.5 0.5
Ns 96.0

newmtl mat13
Ka 1.0 0.33 0.0
Kd 1.0 0.33 0.0
Ks 0.5 0.5 0.5
Ns 96.0

newmtl mat18
Ka 1.0 0.61 0.25
Kd 1.0 0.61 0.25
Ks 0.5 0.5 0.5
Ns 96.0

newmtl mat11
Ka 0.0 0.31 0.25
Kd 0.0 0.31 0.25
Ks 0.5 0.5 0.5
Ns 96.0
`;

        const objData = `
# Simple OBJ Model
mtllib materials.mtl

# White box (mat21)
usemtl mat21
v -1.0 -0.5 0.0
v 1.0 -0.5 0.0
v 1.0 0.5 0.0
v -1.0 0.5 0.0
v -1.0 -0.5 0.5
v 1.0 -0.5 0.5
v 1.0 0.5 0.5
v -1.0 0.5 0.5
vn 0.0 0.0 1.0
vn 0.0 0.0 -1.0
vn 0.0 1.0 0.0
vn 0.0 -1.0 0.0
vn 1.0 0.0 0.0
vn -1.0 0.0 0.0
f 1//2 2//2 3//2 4//2
f 5//1 6//1 7//1 8//1
f 4//3 3//3 7//3 8//3
f 1//4 2//4 6//4 5//4
f 2//5 6//5 7//5 3//5
f 1//6 5//6 8//6 4//6

# Orange top (mat13)
usemtl mat13
v -0.8 0.5 0.1
v 0.8 0.5 0.1
v 0.8 0.5 0.4
v -0.8 0.5 0.4
v -0.5 1.0 0.15
v 0.5 1.0 0.15
v 0.5 1.0 0.35
v -0.5 1.0 0.35
vn 0.0 1.0 0.0
f 9//7 10//7 11//7 12//7
f 13//7 14//7 15//7 16//7
f 9//7 13//7 16//7 12//7
f 10//7 14//7 15//7 11//7
f 9//7 10//7 14//7 13//7
f 12//7 11//7 15//7 16//7

# Teal accent (mat11)
usemtl mat11
v -0.3 -0.5 0.5
v 0.3 -0.5 0.5
v 0.3 0.5 0.5
v -0.3 0.5 0.5
v -0.2 -0.5 0.7
v 0.2 -0.5 0.7
v 0.2 0.5 0.7
v -0.2 0.5 0.7
vn 0.0 0.0 1.0
f 17//8 18//8 19//8 20//8
f 21//8 22//8 23//8 24//8
f 17//8 21//8 24//8 20//8
f 18//8 22//8 23//8 19//8
f 20//8 19//8 23//8 24//8
f 17//8 18//8 22//8 21//8

# Black details (mat23)
usemtl mat23
v -0.9 -0.4 0.5
v -0.7 -0.4 0.5
v -0.7 -0.2 0.5
v -0.9 -0.2 0.5
vn 0.0 0.0 1.0
f 25//9 26//9 27//9 28//9

v 0.7 -0.4 0.5
v 0.9 -0.4 0.5
v 0.9 -0.2 0.5
v 0.7 -0.2 0.5
f 29//9 30//9 31//9 32//9

# Light Orange stripe (mat18)
usemtl mat18
v -1.0 0.0 0.5
v 1.0 0.0 0.5
v 1.0 0.1 0.5
v -1.0 0.1 0.5
f 33//9 34//9 35//9 36//9
`;

        // Touch gesture variables
        let touchDown = false;
        let touchX = 0;
        let touchY = 0;
        let deltaX = 0;
        let deltaY = 0;

        // Initialize Three.js
        function init() {
            // Create Scene
            scene = new THREE.Scene();

            // Create Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 5);

            // Create Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            // Add AR Button
            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.getElementById('content') }
            });
            document.body.appendChild(arButton);

            // Initialize loaders
            objLoader = new OBJLoader();
            mtlLoader = new MTLLoader();

            // OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 2;
            controls.maxDistance = 10;
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, -0.2);
            controls.update();

            const directionalLight = new THREE.DirectionalLight(0xdddddd, 1);
            directionalLight.position.set(0, 0, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const ambientLight = new THREE.AmbientLight(0x222222, 1);
            scene.add(ambientLight);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const reticleGeometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Setup thumbnail generation
            setupThumbnailRenderer();

            // Load default model
            loadDefaultModel();

            // Touch event listeners
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);

            window.addEventListener('resize', onWindowResize, false);
            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);
            document.getElementById('place-button').addEventListener('click', arPlace);

            // Thumbnail click handlers will be added after generation

            // Start animation loop
            renderer.setAnimationLoop(render);
        }

        // Load default model
        function loadDefaultModel() {
            loadOBJModel();
        }

        // Load OBJ Model with materials
        function loadOBJModel() {
            // Show loading
            const loading = document.getElementById('loading');
            loading.classList.remove('hidden');

            // Remove previous object
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }

            try {
                // Parse MTL data
                const materials = mtlLoader.parse(mtlData, '');
                materials.preload();

                // Set materials for OBJ loader
                objLoader.setMaterials(materials);

                // Parse OBJ data
                const object = objLoader.parse(objData);

                // Configure the loaded object
                object.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Ensure materials are properly configured
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    mat.needsUpdate = true;
                                });
                            } else {
                                child.material.needsUpdate = true;
                            }
                        }
                        
                        if (child.geometry) {
                            child.geometry.computeVertexNormals();
                        }
                    }
                });

                // Center and scale the object
                centerAndScaleObject(object);
                
                currentObject = object;
                scene.add(currentObject);

                // Generate thumbnails
                generateThumbnails();

                // Hide loading
                setTimeout(() => {
                    loading.classList.add('hidden');
                }, 300);

            } catch (error) {
                console.error('Error loading OBJ model:', error);
                loading.innerHTML = 'Error loading model';
                setTimeout(() => {
                    loading.classList.add('hidden');
                }, 2000);
            }
        }

        function setupThumbnailRenderer() {
            thumbnailRenderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                preserveDrawingBuffer: true 
            });
            thumbnailRenderer.setSize(100, 100);
            thumbnailRenderer.setClearColor(0x1a1a1a, 1);

            // Create thumbnail scene
            thumbnailScene = new THREE.Scene();

            // Create thumbnail camera
            thumbnailCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            thumbnailCamera.position.set(0, 0, 3);

            // Add lights to thumbnail scene
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 5, 5);
            thumbnailScene.add(dirLight);

            const ambLight = new THREE.AmbientLight(0x404040, 1);
            thumbnailScene.add(ambLight);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 20, 0);
            thumbnailScene.add(hemiLight);
        }

        // Generate thumbnails from the loaded model
        function generateThumbnails() {
            if (!currentObject || !thumbnailRenderer) return;

            thumbnails = [];
            const container = document.getElementById('thumbnail-container');
            container.innerHTML = '';

            const rotations = [
                { angle: 0, label: 'Front' },
                { angle: 90, label: 'Right' },
                { angle: 180, label: 'Back' },
                { angle: 270, label: 'Left' }
            ];

            rotations.forEach((rotation, index) => {
                // Clone the object for thumbnail
                const thumbnailObj = currentObject.clone();
                thumbnailScene.add(thumbnailObj);

                // Center and scale for thumbnail
                const box = new THREE.Box3().setFromObject(thumbnailObj);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                thumbnailObj.position.x = -center.x;
                thumbnailObj.position.y = -center.y;
                thumbnailObj.position.z = -center.z;

                const maxDim = Math.max(size.x, size.y, size.z);
                const targetSize = 2;
                const scale = targetSize / maxDim;
                thumbnailObj.scale.set(scale, scale, scale);

                // Apply rotation
                thumbnailObj.rotation.y = (rotation.angle * Math.PI) / 180;
                thumbnailObj.rotation.x = -0.2; // Slight tilt for better view

                // Render to canvas
                thumbnailRenderer.render(thumbnailScene, thumbnailCamera);

                // Get image data
                const dataURL = thumbnailRenderer.domElement.toDataURL('image/png');

                // Create thumbnail element
                const thumbDiv = document.createElement('div');
                thumbDiv.className = 'thumbnail-item';
                if (index === selectedThumbnailIndex) {
                    thumbDiv.classList.add('selected');
                }
                thumbDiv.dataset.index = index;
                thumbDiv.title = rotation.label;

                const img = document.createElement('img');
                img.src = dataURL;
                img.alt = rotation.label;

                thumbDiv.appendChild(img);
                container.appendChild(thumbDiv);

                // Add click handler
                thumbDiv.addEventListener('click', () => {
                    selectThumbnail(index);
                    closeNav();
                });

                thumbnails.push(dataURL);

                // Remove from thumbnail scene
                thumbnailScene.remove(thumbnailObj);
            });
        }

        // Select thumbnail
        function selectThumbnail(index) {
            selectedThumbnailIndex = index;
            
            // Update visual selection
            const thumbItems = document.querySelectorAll('.thumbnail-item');
            thumbItems.forEach((item, i) => {
                if (i === index) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
            loadOBJModel();
        }

        // Legacy function for menu compatibility
        function loadModel(modelId) {
            loadOBJModel();
        }

        // Center object
        function centerObject(obj) {
            const box = new THREE.Box3().setFromObject(obj);
            const center = box.getCenter(new THREE.Vector3());
            obj.position.x = -center.x;
            obj.position.y = -center.y;
            obj.position.z = -center.z;
        }

        // Center and scale object to fit in view
        function centerAndScaleObject(obj) {
            // Calculate bounding box
            const box = new THREE.Box3().setFromObject(obj);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Center the object
            obj.position.x = -center.x;
            obj.position.y = -center.y;
            obj.position.z = -center.z;

            // Scale to fit in view (target size around 2 units)
            const maxDim = Math.max(size.x, size.y, size.z);
            const targetSize = 2;
            const scale = targetSize / maxDim;
            obj.scale.set(scale, scale, scale);
        }

        // Menu functions
        function openNav() {
            document.getElementById('mySidenav').classList.add('open');
        }

        function closeNav() {
            document.getElementById('mySidenav').classList.remove('open');
        }

        // Make functions globally accessible
        window.openNav = openNav;
        window.closeNav = closeNav;

        // Touch events
        function onTouchStart(event) {
            if (event.touches.length === 1 && currentObject) {
                touchDown = true;
                touchX = event.touches[0].clientX;
                touchY = event.touches[0].clientY;
            }
        }

        function onTouchEnd(event) {
            touchDown = false;
        }

        function onTouchMove(event) {
            if (!touchDown || !currentObject) return;

            event.preventDefault();

            if (event.touches.length === 1) {
                deltaX = event.touches[0].clientX - touchX;
                deltaY = event.touches[0].clientY - touchY;
                touchX = event.touches[0].clientX;
                touchY = event.touches[0].clientY;

                rotateObject(deltaX, deltaY);
            }
        }

        // Rotate object
        function rotateObject(deltaX, deltaY) {
            if (currentObject) {
                currentObject.rotation.y += deltaX * 0.01;
                currentObject.rotation.x += deltaY * 0.01;
            }
        }

        // AR Session Start
        function onSessionStart() {
            if (currentObject) {
                currentObject.visible = false;
            }
            document.getElementById('place-button').classList.remove('hidden');
        }

        // AR Session End
        function onSessionEnd() {
            document.getElementById('place-button').classList.add('hidden');
            if (currentObject) {
                currentObject.visible = true;
                // Reset position but keep scale
                const currentScale = currentObject.scale.clone();
                centerAndScaleObject(currentObject);
                currentObject.scale.copy(currentScale);
            }
            hitTestSourceRequested = false;
            hitTestSource = null;
        }

        // AR Place function
        function arPlace() {
            if (reticle.visible && currentObject) {
                currentObject.position.setFromMatrixPosition(reticle.matrix);
                currentObject.visible = true;
            }
        }

        // Window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function render(timestamp, frame) {
            // Handle AR hit test
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then((referenceSpace) => {
                        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }
            controls.update();
            if (currentObject && currentObject.visible && !renderer.xr.isPresenting) {
                currentObject.rotation.y += 0.002;
            }
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>